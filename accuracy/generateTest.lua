require 'gap/multigap'
require 'gap/utils'

-- Generate a test set from a text file

-- a test set is a lua table, including:
-- 1. a string with gap
-- 2. an array of correct chars to be filled in.

-- After generating the test set, the function wrote the test set table to accuracy/rawTestFiles/<testsetname>

-- CONFIG
MIN_PREFIX = 5
MAX_PREFIX = 30
MIN_GAP = 1
MAX_GAP = 2

MIN_TAIL = 10

-- method to generate a test_set
-- test_set: a dict with two elements:
-- 1. string_with_gap: string with random gaps denoted with gap_char
-- 2. answer: list of gaps
function generateTestSet(path_to_file, test_set_name, gap_char)
	local f = io.open(path_to_file, "rb")

	if f == nil then
		return nil
	end

    local content = f:read("*all")
    local string_with_gap = ''
		local numbered_string_with_gap = ''
		local pos = 0
    local test_set = {}
    local gap = {}

		local gap_count = 1
    while (pos < #content) do
    	local string_len = math.random(MIN_PREFIX, MAX_PREFIX)
    	string_with_gap = string_with_gap .. content:sub(pos+1, pos + string_len)
    	numbered_string_with_gap = numbered_string_with_gap .. content:sub(pos+1, pos + string_len)
			pos = pos + string_len

    	if pos > #content - MIN_TAIL then
    		break
    	end

    	local gap_len = math.random(MIN_GAP, MAX_GAP)
    	string_with_gap = string_with_gap .. string.rep(gap_char, gap_len)
			numbered_string_with_gap = numbered_string_with_gap .. string.rep(gap_char, gap_len)
			numbered_string_with_gap = numbered_string_with_gap .. '(' ..  gap_count .. ')'
			gap_count = gap_count + 1
    	table.insert(gap, content:sub(pos+1, pos + gap_len))
    	pos = pos + gap_len
    end

		string_with_gap = string_with_gap .. content:sub(pos+1, #content)
		numbered_string_with_gap = numbered_string_with_gap .. content:sub(pos+1, #content)

    test_set.string_with_gap = string_with_gap
		test_set.original_string = content
    test_set.answer = gap
		test_set.gap_char = gap_char
		test_set.numbered_string_with_gap = numbered_string_with_gap

    f:close()
    return test_set
end

-- Run fill in gaps on gerenated test and generate report
-- test_set: test set generated by generateTestSet
-- path_to_report: path to export file
-- result: pdf file exported to path_to_file (include file name)
-- model: model to test
-- structure of report file:
-- 	string_with_gap
-- 	filled in string (red for wrong, green for correct)
-- 	accuracy

function generateReport(test_set, path_to_report, model)

	local string_with_gap = test_set.string_with_gap
	local solution = test_set.answer

	-- get the test result
	local result = fill_multi_gaps(string_with_gap, test_set.gap_char, model)
	local answer = result[1]

	local trueCount = 0
	local wrongCount = 0

	-- writing to txt file
	local report = io.open(path_to_report, "w")

	report:write('Passage with missing characters: \n')
	report:write(test_set.numbered_string_with_gap	)

	report:write('\n\nOriginal passage: \n')
	report:write(test_set.original_string	)

	report:write('\n')
	for count = 1, #answer do
		report:write('\nGap no. ' .. count)
		report:write('\nAnswer by model: ' .. answer[count])
		report:write('\nCorrect answer: ' .. solution[count])
		if (answer[count] == solution[count]) then
		do
			trueCount = trueCount + 1
			-- print ('Matched!')
		end
		else
			wrongCount = wrongCount + 1
			-- print ('Not matched!')
		end
	end

	-- compute accuracy
	local accuracy = trueCount/(#answer)*100

	-- print ('Accuracy: ')
	report:write('\n\nAccuracy: ' .. accuracy)
	report:close()

	local result = {}
	result.trueCount = trueCount
	result.total = #answer
	return result
end

--
-- CHECKPOINT_PATH = 'models/cv/checkpoint_17000.t7'
--
-- -- model for sampling
-- local model = get_model_by_path(CHECKPOINT_PATH)
--
-- local gap_char = find_char_to_represent_gap(model)
--
-- -- print (gap_char)
--
-- local testCase = generateTestSet('accuracy/rawTestFiles/testsetgroup1/prof.txt', 'testset', gap_char)
--
-- generateReport(testCase, 'accuracy/reports/prof.txt', model)
